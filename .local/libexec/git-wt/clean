#!/usr/bin/env bash
set -euo pipefail
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/_lib.sh"
remove_cmd="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/remove"
wt_require_git

usage() {
  cat <<'EOF'
Usage:
  git-wt clean [--container <path>] [--dry-run] [--verbose] [--prune-metadata] [--with-branches] [-i|--interactive]

Remove worktrees whose branches are merged into origin/<default>.

Options:
  --dry-run     Report what would be removed
  --verbose     Report reasons for skipped worktrees
  --prune-metadata  Prune stale worktree entries before scanning
  --with-branches  Delete merged branches (non-interactive)
  -i, --interactive  Confirm each removal and optional branch delete
EOF
}

dry_run=false
verbose=false
interactive=false
prune_metadata=false
with_branches=false
container=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run)
      dry_run=true
      shift
      ;;
    --container)
      container="$(wt_abs_path "$(wt_parse_container_arg "${2:-}")")"
      shift 2
      ;;
    --verbose)
      verbose=true
      shift
      ;;
    --prune-metadata)
      prune_metadata=true
      shift
      ;;
    --with-branches)
      with_branches=true
      shift
      ;;
    -i | --interactive)
      interactive=true
      shift
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      die "unknown flag: $1"
      ;;
  esac
done

container="$(wt_resolve_container "${container:-$PWD}")"
main_dir="$(wt_main_for "$container")"
git_main() { git -C "$main_dir" "$@"; }

default_branch="$(wt_default_branch_for "$container")"
if $dry_run; then
  if $verbose; then
    echo "would fetch origin/$default_branch"
  fi
else
  git_main fetch origin "$default_branch" --quiet || die "git fetch origin $default_branch failed"
fi
base_ref="origin/$default_branch"

if $prune_metadata; then
  if $dry_run; then
    $verbose && echo "would run: git worktree prune"
  else
    git_main worktree prune >/dev/null 2>&1 || true
  fi
fi

pwd_resolved="$(pwd -P)"

skip_reason() {
  local wt_path="$1"
  local branch="$2"

  if [[ ! -d "$wt_path" ]]; then
    echo "missing path"
    return 0
  fi
  if [[ -z "$branch" ]]; then
    echo "no branch"
    return 0
  fi
  if [[ "$wt_path" == "$main_dir" ]]; then
    echo "main worktree"
    return 0
  fi
  if [[ "$wt_path" == "$pwd_resolved" ]]; then
    echo "current directory"
    return 0
  fi
  if ! git -C "$wt_path" rev-parse --git-dir >/dev/null 2>&1; then
    echo "not a git repo"
    return 0
  fi
  if git -C "$wt_path" status --porcelain | grep -q .; then
    echo "dirty"
    return 0
  fi
  if ! git_main show-ref --verify --quiet "refs/heads/$branch"; then
    echo "branch missing"
    return 0
  fi
  if ! git_main merge-base --is-ancestor "refs/heads/$branch" "$base_ref"; then
    echo "not merged"
    return 0
  fi
  return 1
}

prompt_yes_no() {
  local prompt="$1"
  local default="$2"
  local reply

  while true; do
    if [[ "$default" == "yes" ]]; then
      printf "%s [Y/n]: " "$prompt"
    else
      printf "%s [y/N]: " "$prompt"
    fi
    read -r reply </dev/tty || return 1
    reply="${reply:-$default}"
    case "$reply" in
      y | Y | yes | YES) return 0 ;;
      n | N | no | NO) return 1 ;;
    esac
  done
}

worktrees=()
branches=()

current_path=""
current_branch=""
while IFS= read -r line; do
  if [[ -z "$line" ]]; then
    if [[ -n "$current_path" ]]; then
      worktrees+=("$current_path")
      branches+=("$current_branch")
    fi
    current_path=""
    current_branch=""
    continue
  fi

  case "$line" in
    worktree\ *)
      current_path="${line#worktree }"
      ;;
    branch\ refs/heads/*)
      current_branch="${line#branch refs/heads/}"
      ;;
  esac
done < <(git_main worktree list --porcelain)

if [[ -n "$current_path" ]]; then
  worktrees+=("$current_path")
  branches+=("$current_branch")
fi

for i in "${!worktrees[@]}"; do
  wt_path="${worktrees[$i]}"
  branch="${branches[$i]}"

  reason="$(skip_reason "$wt_path" "$branch" || true)"
  if [[ -n "$reason" ]]; then
    if $dry_run || $verbose; then
      echo "skip: $wt_path (branch: ${branch:-<none>}): $reason"
    fi
    continue
  fi

  if $dry_run; then
    echo "would remove worktree: $wt_path (branch: $branch)"
    continue
  fi

  if $interactive; then
    if ! prompt_yes_no "Remove worktree $wt_path?" "yes"; then
      continue
    fi
  fi

  wt_remove_worktree "$container" "$wt_path" false false
  if $verbose; then
    echo "remove: $wt_path (branch: $branch)"
  fi
done

if $with_branches; then
  checked_out=()
  while IFS= read -r line; do
    case "$line" in
      branch\ refs/heads/*)
        checked_out+=("${line#branch refs/heads/}")
        ;;
    esac
  done < <(git_main worktree list --porcelain)

  is_checked_out() {
    local b="$1"
    for cb in "${checked_out[@]}"; do
      if [[ "$cb" == "$b" ]]; then
        return 0
      fi
    done
    return 1
  }

  while IFS= read -r b; do
    case "$b" in
      "$default_branch" | main | master | trunk)
        if $verbose; then
          echo "skip: branch $b: protected"
        fi
        continue
        ;;
    esac

    if is_checked_out "$b"; then
      if $verbose; then
        echo "skip: branch $b: checked out"
      fi
      continue
    fi

    if ! git_main merge-base --is-ancestor "refs/heads/$b" "$base_ref"; then
      if $verbose; then
        echo "skip: branch $b: not merged"
      fi
      continue
    fi

    if $dry_run; then
      echo "would delete branch: $b"
      continue
    fi

    if $interactive; then
      if ! prompt_yes_no "Delete merged branch $b?" "no"; then
        continue
      fi
    fi

    if git_main branch -D "$b" >/dev/null 2>&1; then
      if $verbose; then
        echo "delete: branch $b"
      fi
    else
      if $verbose; then
        echo "skip: branch $b: not deleted"
      fi
    fi
  done < <(git_main for-each-ref --format='%(refname:short)' refs/heads)
fi

if ! $dry_run; then
  set +e
  wt_run_clean_hooks "$container"
  hook_rc=$?
  set -e
  if [[ $hook_rc -ne 0 ]]; then
    die "clean hooks failed"
  fi
fi
