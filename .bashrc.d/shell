# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profiles
# sources /etc/bash.bashrc).
#if [ -f /etc/bash_completion ]; then
#    . /etc/bash_completion
#fi

# make sure bash checks for window size changes (why is this not the default?!?)
shopt -s checkwinsize

# don't blindly execute history expansions, but edit instead
shopt -s histverify

# append to history file when exit
shopt -s histappend

# when tab completing, don't show dotfiles
if [ -n "$PS1" ]; then
    bind 'set match-hidden-files off'
fi

export HISTCONTROL=ignoredups:erasedups

# capture more history
export HISTSIZE=25000
export HISTFILESIZE=25000

export EDITOR=vi

OS=`uname -s`

# if we're running on a mac, use macvim for commit messages
if [ "$OS" == "Darwin" ]
then
    export EDITOR='mvim -v'
fi

function reconnect_ssh_agent() {
    if [[ -n $TMUX ]]; then
        NEW_SSH_AUTH_SOCK=`tmux showenv|grep ^SSH_AUTH_SOCK|cut -d = -f 2`
        if [[ -n $NEW_SSH_AUTH_SOCK ]] && [[ -S $NEW_SSH_AUTH_SOCK ]]; then
            SSH_AUTH_SOCK=$NEW_SSH_AUTH_SOCK
        fi
    fi
}

# check if fzf is installed
function guard_fzf()
{
    if type fzf &> /dev/null; then
        return 0
    fi

    echo "No 'fzf' found"
    return 1
}

# quick switcher for git worktrees
function wts()
{
    guard_fzf || return 1
    dir=$(git worktree list | awk '{ print $1 }' | fzf -1 -q "$1") &&
    cd "$dir"
}

# binding to select snippet in pet
function pet-select() {
  BUFFER=$(pet search --query "$READLINE_LINE")
  READLINE_LINE=$BUFFER
  READLINE_POINT=${#BUFFER}
}
bind -x '"\C-x\C-r": pet-select'

# binding to suffix with less pipe
function less-suffix() {
  READLINE_LINE="$READLINE_LINE | less -RS"
  READLINE_POINT=${#READLINE_LINE}
}
bind -x '"\C-x\C-l": less-suffix'
